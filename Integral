# Author: Julia Baumgarten

"""
Problem Description:
  Coulomb's law in 1D geometry: Electric field on the perpendicular bisector of a uniformly charged finite line. 
  We integrate the smooth kernel and compare our numerical result against the analytic result and against SciPy.

Physics Set-up:
  Line of half-length L along x-axis with linear charge density λ.
  We evaluate E at the point (0, a) by symmetry, only the y-component survives:

    E_y(a) = (1 / (4π ε0)) * ∫_{-L}^{L} [ λ * a / (x^2 + a^2)^{3/2} ] dx

  We let K = λ / (4π ε0), so

    Ey(a, L) = K * ∫_{-L}^{L} a / (x^2 + a^2)^{3/2} dx
             = K * ( 2 L / (a * sqrt(a^2 + L^2)) )   

  This is our analytic closed form.


Usage (short version):
  1) Riemann Midpoint
  2) Trapezoid
  3) Simpson
  4) E_{y} numeric and analytic
  5) error_vs_N     -> loglog error study vs N for each rule
     field_profile  -> E_{y} vs a curve, numeric vs analytic
     compare_scipy  -> numeric value vs SciPy quad/trapezoid/simpson
     (Command Line Modes)

Usage examples:
  python main_integral.py error_vs_N --L 1.0 --a 0.5 --N_list 20 40 80 160 --rules riemann trapezoid simpson --plot
  python main_integral.py field_profile --L 1.0 --a_min 0.1 --a_max 4.0 --n_a 50 --rule simpson --N 400 --plot
  python main_integral.py compare_scipy --L 1.0 --a 0.5 --rule simpson --N 400
"""

# ----------------------------- Import ----------------------------- #
import argparse
import math
import sys
from dataclasses import dataclass
from typing import Callable, Iterable, List, Tuple
import numpy as np

# ----------------------------- Physics model ----------------------------- #
@dataclass
class CoulombLineParams:
    L: float  # half-length of the charged segment
    a: float  # distance from the line along the perpendicular bisector
    K: float = 1.0  # constant λ/(4π ε0). We keep as 1 by default to focus on numerics


def ey_kernel(x: np.ndarray | float, a: float) -> np.ndarray | float:
    """
    Kernel for the y-component of E on the perp. bisector:
      f(x; a) = a / (x^2 + a^2)^(3/2)
    This is smooth on [-L, L] for a > 0
    """
    return a / np.power(x * x + a * a, 1.5)


def ey_analytic(p: CoulombLineParams) -> float:
    """
    Closed-form result:
      Ey(a, L) = K * 2L / (a * sqrt(a^2 + L^2))
    """
    return p.K * (2.0 * p.L) / (p.a * math.sqrt(p.a * p.a + p.L * p.L))

# ----------------------------- Quadrature rules ----------------------------- #

def riemann_midpoint(f: Callable[[np.ndarray], np.ndarray], a: float, b: float, N: int) -> float:
    """
    Midpoint Riemann sum on [a, b] with N uniform subintervals.
    Order O(h^2) for smooth f, where h = (b - a) / N
    """
    if N <= 0:
        raise ValueError("N must be positive.")
    h = (b - a) / N
    # midpoints of each subinterval
    m = (np.arange(N, dtype=float) + 0.5) * h + a
    return float(h * np.sum(f(m)))


def trapezoid(f: Callable[[np.ndarray], np.ndarray], a: float, b: float, N: int) -> float:
    """
    Composite trapezoidal rule on [a, b] with N panels (N+1 nodes).
    Global error O(h^2) for smooth f.
    """
    if N <= 0:
        raise ValueError("N must be positive.")
    h = (b - a) / N
    x = np.linspace(a, b, N + 1)
    y = f(x)
    return float(h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1]))


def simpson(f: Callable[[np.ndarray], np.ndarray], a: float, b: float, N: int) -> float:
    """
    Composite Simpson's rule on [a, b] with N panels (requires N even).
    Global error O(h^4) for smooth f.
    """
    if N <= 0:
        raise ValueError("N must be positive.")
    if N % 2 != 0:
        raise ValueError("Simpson's rule requires N to be even.")
    h = (b - a) / N
    x = np.linspace(a, b, N + 1)
    y = f(x)
    # weights: 1, 4, 2, 4, ..., 2, 4, 1
    S = y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2])
    return float(h * S / 3.0)














